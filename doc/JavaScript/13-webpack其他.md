## 关于模块化

### node中的模块化

对于CommonJS模块化，Node.js会根据模块名来查找模块，查找规则如下：

1. 如果模块名是一个核心模块（比如`fs`、`path`等），则直接返回该模块；
2. 如果模块名以`./`、`../`或`/`开头，则表示该模块是一个相对路径或绝对路径，Node.js会根据该路径来查找模块；
3. 如果模块名不是一个核心模块，并且也不是以`./`、`../`或`/`开头，则表示该模块是一个第三方模块，Node.js会在`node_modules`目录下查找该模块，如果找不到，则向上一级目录继续查找，直到找到为止。如果最终还是找不到，则会抛出一个`ModuleNotFoundError`错误。

对于ES6模块化，Node.js使用的是ECMAScript规范中的模块解析规则，查找规则如下：

1. 如果模块名是一个核心模块（比如`fs`、`path`等），则直接返回该模块；
2. 如果模块名以`./`或`../`开头，则表示该模块是一个相对路径模块，Node.js会根据该路径来查找模块；
3. 如果模块名不是一个核心模块，并且也不是以`./`或`../`开头，则表示该模块是一个第三方模块。Node.js会在`node_modules`目录下查找该模块，并且会查找该模块中是否包含一个`package.json`文件。如果存在`package.json`文件，并且该文件中有一个`"module"`字段，则会使用该字段指定的入口文件。否则，会查找该模块中是否包含一个`index.js`或`index.mjs`文件作为入口文件。
4. 如果在指定入口文件或默认入口文件中还无法找到该模块，则会向上一级目录继续查找，直到找到为止。如果最终还是找不到，则会抛出一个`ModuleNotFoundError`错误。

需要注意的是，在Node.js中，ES6模块化是通过在文件中使用`import`和`export`关键字来实现的，而CommonJS模块化则是通过在文件中使用`require`函数和`module.exports`对象来实现的。

### 浏览器的模块化

浏览器原生不支持node_modules目录的查找，所以需要使用打包工具，如Webpack等，将node_modules中的第三方模块打包成一个文件，并通过打包后的文件路径进行导入。

浏览器的 ES6 模块化规范只支持使用相对或绝对路径导入模块。如果使用非相对或非绝对路径，例如 `import _ from 'loadsh'`，浏览器会将其解析为全局模块，但是浏览器并不支持全局模块，因此会报错。

在浏览器中，ES6模块化的模块查找规则与Node.js有一些不同。具体来说，浏览器会从以下位置查找模块：

1. 如果模块名是一个URL，浏览器会下载该URL指定的模块，并将其作为模块返回；
2. 如果模块名以`./`或`../`开头，则表示该模块是一个相对路径模块，浏览器会根据该路径来查找模块；
3. 如果模块名不是一个URL，并且也不是以`./`或`../`开头，则表示该模块是一个顶级模块或第三方模块。浏览器会在当前页面的`<script type="module">`标签指定的`<script>`标签列表中查找该模块，如果找到了对应的`<script>`标签，则浏览器会解析该标签中的JavaScript代码，并将其作为模块返回。如果没有找到对应的`<script>`标签，则会向上一级目录继续查找，直到找到为止。

需要注意的是，浏览器中的ES6模块化要求模块文件的MIME类型必须是`text/javascript`或`text/ecmascript`，否则浏览器会报错。此外，浏览器中的ES6模块化默认采用严格模式，因此模块中的代码必须遵循严格模式的语法规则。

**如果没有webpack，我们就需要手动将所有的模块文件和它们的依赖手动打包成一个单独的JavaScript文件。这个过程需要手动处理所有的依赖关系，并且需要保证所有的依赖关系都正确地按照顺序加载。这个过程比较繁琐，并且容易出错，因此使用webpack这样的工具可以自动化这个过程，减少出错的可能性，提高开发效率。**

假设我们有一个 `index.html` 文件和一个 `app.js` 文件，我们想要在 `app.js` 中引入 lodash 模块。可以通过以下步骤实现：

1. 在 `index.html` 文件中添加一个 `<script>` 标签，用于引入 lodash 库：

```
htmlCopy code
<script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
```

这里我们使用了 jsdelivr 的 CDN 来获取 lodash 库的最新版本。

1. 在 `app.js` 文件中使用 ES6 模块语法引入 lodash 模块：

```
jsCopy codeimport _ from 'lodash';

console.log(_.chunk(['a', 'b', 'c', 'd'], 2));
```

在这个例子中，我们使用了 `import` 语法从 lodash 模块中导入 `_` 对象，然后在控制台中输出了一个数组，该数组将输入数组分成大小为 2 的块。

这样，我们就可以在浏览器中使用 lodash 模块了，而不需要使用 webpack 或其他构建工具。

### webpack中的模块化

在 Webpack 中，对已经编译好的第三方模块包的入口文件做依赖图是为了构建应用程序的依赖图，并将所有依赖的模块打包到一个或多个输出文件中。这个过程也被称为“打包”。

当我们使用 Webpack 构建应用程序时，我们需要告诉 Webpack 如何处理应用程序中的模块。在 Webpack 中，可以通过配置文件来指定如何处理模块。其中，配置文件中的入口文件指定了应用程序的入口点，而 Webpack 会从入口文件开始构建依赖图，自动查找所有依赖的模块，并将它们打包到输出文件中。

webpack是基于Node.js构建的，因此它遵循了Node.js的模块化规范。webpack原生支持的模块化规范包括CommonJS和ES6模块化。除此之外，webpack还可以通过插件扩展其支持的模块化规范，例如AMD（Asynchronous Module Definition）和UMD（Universal Module Definition）等。

## tree shaking

代码能够被tree shaking的条件

1. **ES6 模块化**: Tree shaking **只支持 ES6 模块化语法**。这是因为 ES6 模块化语法支持静态分析，编译器可以在不执行代码的情况下，就知道哪些部分是被使用的，哪些部分是不需要的。
2. **函数或类没有被调用或实例化**: 如果某个函数或类没有被调用或实例化，那么它的代码就不会被执行。因此，Tree shaking 就可以将这部分代码从打包结果中移除。
3. **未被引用的变量或常量**: 如果一个变量或常量没有被引用，那么它也就不会被使用。在 Tree shaking 的过程中，这部分代码也会被移除。
4. **副作用较少的代码**: 在编写代码的过程中，我们经常会写一些有副作用的代码，比如操作 DOM，向服务器发送请求等。这些代码虽然可能没有被直接使用，但由于它们会对应用程序的状态产生影响，因此它们的代码不能被移除

## source-map

Source Map（源代码映射）是一种文件格式，它提供了一种将编译后的代码映射回原始源代码的方法。在前端开发中，当我们使用 JavaScript、CSS 等语言编写代码并打包压缩后，这些代码变得难以阅读和调试。使用 Source Map 可以将编译后的代码映射回原始源代码，从而方便开发人员在调试时查看、定位问题。

在 webpack 中，可以通过配置选项来生成 Source Map 文件。在 webpack 打包时，如果开启了 Source Map，会生成一个单独的 .map 文件，这个文件记录了压缩后的代码和原始源代码的映射关系。这个 .map 文件可以被浏览器调试工具使用，当开发人员在调试时遇到问题时，工具会使用这个文件将编译后的代码映射回原始源代码，从而方便开发人员查看和定位问题。

在 bundle.js 中，如果启用了 Source Map，会在 bundle.js 文件中生成一段 Source Map URL，它通常被称为 Source Map 注释。这个注释指向了单独的 .map 文件，浏览器可以通过这个注释下载 Source Map 文件并将编译后的代码映射回原始源代码。

需要注意的是，启用 Source Map 会对性能产生一定的影响，因此在生产环境下应该关闭 Source Map。在开发环境下，建议启用 Source Map 来方便调试。

## 问题

- 只有webpack打包之后的文件，bundle.js文件的样子是怎样的？
- 生产模式和开发模式
- 什么时候插入组件

